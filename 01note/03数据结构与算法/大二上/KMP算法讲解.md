## 如何更好地理解和掌握KMP算法？

KMP算法的核心，是一个被称为**部分匹配表**（Partial Match Table）的数组。

对于字符串“abababca”，它的PMT如下：

| char: | a    | b    | a    | b    | a | b | c |a|
| ----- | ---- | ---- | ---- | ---- | ---- |---|---|---|
|index:| 0 | 1 | 2 | 3 | 4 | 5 |6|7|
|value:| 0 | 0 | 1 | 2 | 3 | 4 |0|1|

就像例子中所示的，如果待匹配的模式字符串有8个字符，那么PMT就会有8个值。

这里先解释一下字符串的前缀和后缀。如果字符串A和B，存在A=BS，其中S是任意的非空字符串，就称B为A的前缀。例如，“Harry”的前缀包括{“H”，“Ha”，“Har”，“Harr”}，我们把前缀组成的集合，称为字符串的前缀集合。同样可以定义后缀A=SB，其中S为任意的非空字符串，那就称B为A的后缀集合，例如，“Potter”的后缀集合包括{“otter”，“tter”，“ter”，“er”，“r“}，把所有后缀组成的集合，称为字符串的后缀集合。要注意的是，字符串本身并不是自己的后缀。

有了这个定义，就可以说明PMT中的值的意义了。**PMT中的值是字符串的前缀集合与后缀集合的交集中最长元素的长度**。

>   例如，对于”aba“，它的前缀集合为{”a“，”ab“}，后缀集合为{”ba“，”a“}。两个集合的交集为{”a“}，那么长度最长的元素就是字符串”a“了，长度为1，所以对于”aba“而言，它在PMT表中对应的值就是1。再比如，对于字符串”ababa“，它的前缀集合为{”a“，”ab“，”aba“，”abab”}，它的后缀集合为{“baba”，“aba“，”ba“，”a”}，它的交集为{“a”，“aba”}，其中最长的元素为“aba”，长度为3。

好了，解释清楚这个表是什么之后，我们再来看使用这个表来加速字符串的查找，以及这样用的道理是什么。

要在主字符串"ababababca"中查找模式字符串"abababca"。如果模式串中的第j处字符与主串的第i处不匹配，

![KMP-1](https://pic1.zhimg.com/v2-03a0d005badd0b8e7116d8d07947681c_r.jpg?source=1940ef5c)

由于PMT的性质，主串中的i指针之前的（j-1）位字符与模式串的0位-（j-1）位是相同的。

>   这是因为主串中的第i处字符失配，也就意味着主串的第（i-j）位-第i位与模式串的第0位-第（j-1）位这一段是相同的。

而上面也解释了，模式串从0-（j-1），就是“ababab”，其前缀集合与后缀集合的交集的最长元素是“abab”，长度为4，可以断言，主串的i位之前的前4位字符串与模式串的第0位至第4位的字符串是相同的，即长度为4的前缀与后缀相同。

这样就可以直接将这些字符串省略，具体做法就是：保持指针i不动，然后将指针j移动到PMT[j-1]，即图（b）

有了上面的思路，就可以使用PMT加速字符串的查找了。而且**只需要关注模式串即可**，与主串的字符串情况无关。假如是模式串的第j位失配，那么影响的指针j的回溯位置实际上是（j-1）的PMT值，所以为了编程方便，我们不直接使用PMT数组，而是将它后移一位，我们把新得到的数组称为next数组。

下面给出根据next数组进行字符串匹配加速的字符串匹配程序。其中要注意的一个技巧是，在把PMT进行[向右偏移](https://www.zhihu.com/search?q=向右偏移&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A281346746})时，第0位的值，我们将其设成了-1，这只是为了编程的方便，并没有其他的意义。在本节的例子中，next数组如下表所示。

![PMT-2](https://pic3.zhimg.com/v2-40b4885aace7b31499da9b90b7c46ed3_r.jpg?source=1940ef5c)

next数组即为第j位失配，则跳转到next[j]。比如说下标为3的b处失配，next[3]=1，指针j跳转到下标为1的b处，再次开始匹配

好了，讲到这里，其实KMP算法的主体就已经讲解完了。你会发现，其实KMP算法的动机是很简单的，解决的方案也很简单。远没有很多教材和算法书里所讲的那么乱七八糟，只要搞明白了PMT的意义，其实整个算法都迎刃而解。

现在，我们再看一下**如何编程快速求得next数组**。

其实，求next数组的过程完全可以看成字符串匹配的过程，即以模式字符串为主字符串，以模式字符串的前缀为目标字符串，一旦字符串匹配成功，那么当前的next值就是匹配成功的字符串的长度。

具体来说，就是从模式字符串的第一位(注意，不包括第0位)开始对自身进行匹配运算。 在任一位置，能匹配的最长长度就是当前位置的next值。如下图所示。

![KMP-3](https://pic3.zhimg.com/80/v2-645f3ec49836d3c680869403e74f7934_720w.webp?source=1940ef5c)

![img](https://pica.zhimg.com/80/v2-06477b79eadce2d7d22b4410b0d49aba_720w.webp?source=1940ef5c)

![img](https://pic2.zhimg.com/80/v2-8a1a205df5cad7ab2f07498484a54a89_720w.webp?source=1940ef5c)

![img](https://pic1.zhimg.com/80/v2-f2b50c15e7744a7b358154610204cc62_720w.webp?source=1940ef5c)

![img](https://pic2.zhimg.com/80/v2-bd42e34a9266717b63706087a81092ac_720w.webp?source=1940ef5c)

求next数组值的程序如下所示：

```c
void getNext(char * p, int * next)
{
	next[0] = -1;
	int i = 0, j = -1;

	while (i < (int)strlen(p))
	{
		if (j == -1 || p[i] == p[j])
		{
			++i;
			++j;
			next[i] = j;
		}	
		else
			j = next[j];
	}
}
```







自测：



```c
void getNext(char * p, int * next)
{
    next[0] = -1;
    int i=0, j=-1;
    while (i<(int)strlen(p))
    {
        if (j == -1 || next[i] = next[j])
        {
            ++i;
            ++j;
            next[i] = j;
        }
        else 
            j = next[j];
    }
}
```

