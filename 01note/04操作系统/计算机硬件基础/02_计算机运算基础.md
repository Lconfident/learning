## 带符号数的编码

### 原码

符号位不参与运算，主要实现乘除运算

正数的符号位：0

负数的符号位：1

数位部分与真值位部分完全相同

> 已知X = 1011，字长为5，原码为 X(原) = 0	1011
>
> Y = -1110，字长为5，原码为 X(原) = 1	1110

### 补码

符号位可参与运算，主要实现加减运算

正数的补码是本身

负数的补码是模与该负数绝对值的差值

一般求法：符号位不变，其余各位按位取反，加一

> 字长为8，可以表示256个数字，，即0~256，但要表示负数，咋办？就用该负数同余的正数表示，-1 = 255,-2 = 254,-128 = 256-128 = 128,模就是256（2的8次方）
>
> 无符号正数：0~256，有符号数：-128~127

### 反码

正数的反码和原码一样

负数的反码，将数值位按位取反

### 移码

正数的符号位用1表示。数位部分同真值一样

负数的符号位用0表示，数位部分取反加一

### 总结

1. 原码和反码表示的数的范围是相对于0对称的，表示的范围也相同
2. 补码和移码表示的数的范围是相同，但相对于0 不对称
3. 当字长为n时，都可以有2的n次方个编码，但原码和反码表示0用了两个编码，而补码和移码表示0 只用了一个编码。 则同样的字长，补码和移码可以多表示一个负数

## 定点数的表示

### 定点整数

将小数点位置固定在最低有效位后，定点整数是纯整数

表示范围：

原码、反码：-(2^n-1^-1) ~ (2^n-1^-1)

补码、移码：-(2^n-1^) ~ (2^n-1^-1)

### 定点小数

将小数点位置固定在最高有效位和符号位之间，定点小数是纯小数

表示范围：

原码、反码：-(1-2^-(n-1)^) ~ (1-2^-(n-1)^)

补码：-1 ~ （1-2^-(n-1)^）

> 这里讲一下补码为啥最小负数固定是-1？
>
> 按位取反加一，补码1.000 0000的真值不是-1呀，不急
>
> 首先来根据补码定义得出，模与该负数绝对值的差值，（纯小数补码，模取2）
>
> -1的补码为2-1.0 = 1.000 0000
>
> 其次，（8位）补码要想得到最小负数，则数位部分全为000 0000，即1.000 0000

### 无符号数

不设符号位的正整数

0 ~ (2^n-1^-1)

## 浮点数的表示

### 浮点数表示的格式和特点

任意一个二进制均可表示为 

N = M * 2^E^

M为数N的尾数，决定精度（定点小数表示）

E为数N的阶码，决定大小（定点整数表示）

阶符 - 阶码值 - 数符 - 尾数值

E~f~E~1~E~2~ ...E~m~M~f~M~1~M~2~...M~n~

### 浮点数的表示范围和规格化

阶码取最大正数，尾数取最大正数-》最大正数

阶码取最大正数，尾数取最小负数-》最小负数

阶码取最小负数，尾数取最小非0正数-》最小非0正数

阶码取最小负数，尾数取最大非0负数-》最大非0负数

尾数规格化处理后：

提升了精度

> 原码：正数 0.1 xxx   负数 1.1xxx
>
> 补码：正数 0.1xxx    负数 1.0xxx

显然，最小非0正数和最大非0负数变化

以4位阶码4位尾数为例，阶码和尾数均用补码表示：

最小非0正数补码表示：1000 0100

最大非0负数补码表示：1000 1011

### IEEE754标准

浮点数尾数用原码，阶码用移码，基数为2

规格化原码尾数的最高位要求恒为1，为增加一位的精度，这个1在尾数中不显现(隐藏位），计算时在尾数前面自动加1 ：

先将数变为下面的形式 

N =1. M×2^x^

再求浮点数对应的移码(8位）:

E= X+127(尾数左移一位，阶码减一    -1和+127的性质一样，移码表示，对称的)
